import json
import sqlite3

LOG_FILE = 'data/log.json'
DB_FILE = 'data/seen_malware.sqlite3'
TABLE = 'seen_malware'

# enum like
DISPOSITION = {
    'MALICIOUS': 1,
    'CLEAN': 2,
    'UNKNOWN': 3
}


def read_logs(log_file):
    """
    read and parse logs from log_file.
    :param log_file: logs file
    :return: list of log enteries
    """
    logs = []

    try:
        with open(LOG_FILE) as f:
            for log in f.readlines():
                logs.append(json.loads(log))

    except OSError as e:
        print(e)

    return logs


def find_fictitious(logs):
    """
    read logs and get fictitious enteries.
    :param logs: list of log enteries
    :return: list of sha's of fictitious malware
    """
    ficitious_sha = []

    for log in logs:
        if log['dp'] == DISPOSITION['UNKNOWN']:
            ficitious_sha.append(log['sha'])

    return ficitious_sha


def create_connection(db_file):
    """
    create a database connection to the SQLite database
    specified by the db_file.
    :param db_file: database file
    :return: Connection object or None
    """
    conn = None
    try:
        conn = sqlite3.connect(db_file)

    except sqlite3.Error as e:
        print(e)

    return conn


def select_all_malware(conn):
    """
    query all rows in the TABLE.
    :param conn: the Connection object
    :return: dict of all enteries of TABLE with {sha: cnt} 
    """
    SHA = 0
    CNT = 1

    try:
        malware_dict = {}

        for m in conn.execute(f'SELECT * FROM {TABLE};'):
            malware_dict[m[SHA]] = m[CNT]

    except sqlite3.Error as e:
        print(e)

    return malware_dict


def update__seen_malware(conn, emd, fml):
    """
    For each fictitious entry, update TABLE as follows:
        * if the file has been seen before
            * increment the database count (`cnt`) by 1
        * if the file is new
            * insert a new entry with `count == 1` and disposition (`dp`) == UNKNOWN
    :param conn: the Connection object
    :param emd (existing malware dict): {sha: cnt} dict of all malware 
    :param fml (fictitious malware list): list of ficitious malware sha's
    :return: 
    """
    # sql queries
    update = f'UPDATE {TABLE} SET cnt = ? WHERE sha = ?;'
    insert = f'INSERT INTO {TABLE} VALUES (?, ?, ?);'

    batch_update = []
    batch_insert = []

    # count fictictious malware
    for sha in fml:
        cnt = emd.get(sha, 0)

        if cnt == 0:
            batch_insert.append((sha, 1, DISPOSITION['UNKNOWN']))
        else:
            batch_update.append((cnt + 1, sha))

    # record changes in the database
    try:
        with conn:
            conn.executemany(insert, batch_insert)
            conn.executemany(update, batch_update)

    except sqlite3.Error as e:
        print(e)


def main():
    conn = sqlite3.connect(DB_FILE)
    logs = read_logs(LOG_FILE)

    existing_malware_dict = select_all_malware(conn)
    ficitious_malware_list = find_fictitious(logs)

    try:
        update__seen_malware(
            conn=conn,
            emd=existing_malware_dict,
            fml=ficitious_malware_list
        )

    finally:
        if conn:
            conn.close()


if __name__ == "__main__":
    main()

# NOTES:
#
# We could add parallelization when filtering for fictitious logs 
# in larger log files. But didn't wanna do it now as to avoid over-engineering.
# 
# We could do a bit more of research around sqlite3 to make our writes faster.